<!DOCTYPE html>
<html lang="ru">
	<!-- 5:00:00 так и не вывез переписать пример на вариант с явным возвратом объекта -->
	<!-- 8:37:00 классы и прототипы -->
	<!-- 1620, время - 9:17 (Статические методы)-->
	<!-- 1637-1656, time 9:26:18 -->
	<!-- Нужно более подробно изучить метод reduce -->
	<!-- 9:38:00 Промисы 1696 -->
	<!-- 10:16:00  -->
	<!-- 1871 строка,  10:42:00 (пояснение примера с переписыванием промисов на асинх|эвэйт)-->
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Конспект по JS</title>
		<link rel="stylesheet" href="../Стащук/CSS/normalize.css">
		<link rel="stylesheet" href="../Стащук/CSS/style.css">
	</head>

	<body>
		<div class="up_ward" onclick="scrollTopTop()">
			<svg width="40px" height="40px" viewbox="0 0 24 24" fill="none"
				xmlns="http://www.w3.org/2000/svg">
				<path d="M8 12L12 8M12 8L16 12M12 8V20M4 4H20" stroke="currentColor"
					stroke-width="2" stroke-linecap="round"
					stroke-linejoin="round" />
			</svg>
		</div>
		<div class="container">
			<h1>Конспект по JS</h1>
			<h2>Самое важное в JavaScript</h2>
			<ul>
				<li>
					<a href="#objects">
						Объекты
					</a>
				</li>

				<li>
					<a href="#expressions">
						Выражения
					</a>
				</li>

				<li>
					<a href="#functions">
						Функции
					</a>
				</li>
			</ul>
			<p id="object">
				Объект&nbsp;&mdash; это набор свойств &laquo;ИМЯ: ЗНАЧЕНИЕ&raquo; =
				&laquo;КЛЮЧ: ЗНАЧЕНИЕ&raquo;
				<h3>
					Пример объекта:
				</h3>
				<code>
					{<br>
					visible: true,<br>
					colorDepth:24,<br>
					title:'My Image',<br>
					orientation: {<br>
					angle: 0,<br>
					type: 'landscape'<br>
					},<br>
					pixelDepth:24,<br>
					width: 1440<br>
					}
				</code>
			</p>
			<p>
				<h3>
					Что является объектами:
				</h3>
				<ul>
					<li>
						Массивы
					</li>
					<li>
						Функции
					</li>
				</ul>
			</p>
			<p>
				<h3>
					Что ведёт себя как объект:
				</h3>
				<ul>
					<li>
						Число
					</li>
					<li>
						Строка
					</li>
				</ul>
			</p>

			<p>
				Значения типа &laquo;ЧИСЛО&raquo; или &laquo;СТРОКА&raquo;&nbsp;&mdash; это
				примитивные значения. <br>
				Примитивные типы данных - это типы данных, которые не являются объектами и
				не могут иметь никаких методов или свойств. Эти типы данных называются
				«примитивными», потому что они неизменяемы, что означает, что их значения не
				могут быть изменены после их создания.
			</p>
			<div>
				<h2>console.log('Hello World')</h2>
				<ul>
					<li>
						<b>console</b>&nbsp;&mdash; это объект, который имеет в&nbsp;себе пару
						ключ-значение.
					</li>
					<li>
						<b>log</b>&nbsp;&mdash; это метод (функция). Метод&nbsp;&mdash; это
						свойство объекта, значение которого - функция.
					</li>
					<li>
						&laquo;<b>.</b>&raquo; - это точечная запись, с&nbsp;помощью которой
						можно получать доступ к&nbsp;свойствам
						объекта.
					</li>
					<li>
						<b>[...]</b> Кроме точечной записи мы&nbsp;можем использовать квадратные
						скобки. Их&nbsp;можно использовать
						для
						добавления
						свойств. <br>
						Такая запись используется, если название свойство&nbsp;&mdash; это
						название переменной. (//*48) <br>
						<strong>точечную запись&nbsp;и [...] можно комбинировать&nbsp;&mdash; ЭТО
							ИСПОЛЬЗУЕТСЯ ПРИ ВЛОЖЕННЫХ
							СВОЙСТВАХ. <br>
							<strong>Чтобы добавить свойство с помощью ['свойство'], свойство нужно
								указать в виде строки '' </strong>
							(//*45)</strong> <br>
						<p>
							[] так же помогают нам, если название свойства совпадает с названием
							переменной. Например: <br>
						</p>
						<code>
							const myCity = { <br>
							city: 'New York' <br>
							} <br>
							<br>
							myCity['popular'] = true <br>
							console.log(myCity) // {city: 'New York', popular: true} <br>
							<br>
							const countryPropertyName = 'country' <br>
							myCity[countryPropertyName] = 'USA' <br>
							<br>
							console.log(myCity) // {city: 'New York', popular: true, country: 'USA'}
							<br>
						</code>
						<p>Ещё с помощью квадратных скобок можно получать доступ к элементам
							массива, указывая в скобках индекс массива (индексы считаются, начиная с
							0)</p>
					</li>
					<li>
						<b>( )</b> () - это вызов метода.
					</li>
					<li>
						<b>&rsquo;Hello World&rsquo;</b> - &rsquo; Hello World&rsquo; - Это
						значение типа
						&laquo;СТРОКА/str/String&raquo;
					</li>
				</ul>
				<p>Так&nbsp;же у&nbsp;объекта console есть другие методы:</p>
				<ul>
					<li>
						log
					</li>
					<li>
						dir
					</li>
					<li>
						table
					</li>
				</ul>
				<p>
					Если свойства и названия переменных совпадают, можно не писать свойство как
					"= {name: name,}", а просто написать "= {name,}"
				</p>
				<p>dir отображает все свойства объекта</p>
				<p>table отображает все свойства объекта в&nbsp;виде таблицы</p>
				<p>
					<strong>Функция возвращает UNDEFINED, если нет инструкции RETURN
						(//*214)</strong>
				</p>
				<p>
					<b>Важно:</b> значения переменных внутри функции определяются только при
					вызове этой функции.
				</p>
			</div>

			<div id="expressions" class="section">
				<h2>Выражения.</h2>
				<p>
					<b>Выражение всегда возвращает значение.</b>
					Значит:
					<b>Вызов функции&nbsp;&mdash; это выражение, потому что оно всегда
						возвращает значение.</b>
				</p>
				<h3>
					К&nbsp;выражениям относятся:
				</h3>
				<p>
					Строки &rsquo;abc&rsquo;<br>
					Числа 10<br>
					числа в&nbsp;виде выражений 5 + 2<br>
					Операторы присвоения c = 10<br>
					&rsquo;Good &rsquo; + &rsquo;Evening&rsquo; Конкатенация строк<br>
					<code>a <= b || c !==d </code> выражение с&nbsp;несколькими
					операторами<br>
					myFunction(c, d) вызов и&nbsp;результат функции
				</p>
				<h3>Выражение присваивания: (a = 24)</h3>
				<p>
					Оператором в&nbsp;этом выражении будет &laquo;=&raquo;<br>
					a&nbsp;&mdash; это переменная<br>
					24&nbsp;&mdash; число (можно присвоить любое)
				</p>
				<h3>Выражение с&nbsp;побочными действиями:</h3>
				<p>
					Они не&nbsp;только возвращают значение, но&nbsp;и&nbsp;выполняют другие
					действия
				</p>
				<p>
					a = 5&nbsp;(Так как задаст переменной значение, то&nbsp;есть выполнит
					другое действие)<br>
					b++&nbsp;(оператор &laquo;++&raquo; увеличивает значение
					на&nbsp;единицу)<br>
					myFunction(c, d)
				</p>
			</div>

			<section class="section">
				<h2>Переменные</h2>
				<p>
					Переменные дают возможность <b>повторного</b> доступа к&nbsp;значениям,
					которые присвоены значениям. <br>
					Переменные можно воспринимать как &laquo;коробки&raquo; для хранения
					значений, в&nbsp;которые можно
				</p>
				<h3>
					Рекомендовано называть переменные таким образом:
				</h3>
				<ul>
					<li>PascalCase <br>(обычно используется для названия типов
						и&nbsp;классов)</li>
					<li>DB_PASSWORD <br>(Этот подход для названия переменных обычно
						используется, когда значения известны до
						запуска приложения и&nbsp;не&nbsp;меняются)</li>
					<li>camelCase <br>(Рекомендуется называть таким способов переменные
						во&nbsp;всех остальных случаях)</li>
				</ul>
				<p>
					Названия переменных желательно указывать, чтобы была понятна его суть.
				</p>
				<h3>Объявление переменных</h3>
				<p>
					Есть 3&nbsp;ключевых слова, с&nbsp;помощью которых объявляются переменные:
				</p>
				<ul>
					<li>
						let (можно присваивать новое значение)
					</li>
					<li>
						const (нельзя присваивать новые значения)
					</li>
					<li>
						var <br>(не&nbsp;рекомендуется использовать var)
					</li>
				</ul>
				<h4>
					Пример:
				</h4>
				<code>
					let a <br>
					const c = 10 <br>
					a = true
				</code>
				<p>
					первая строка&nbsp;&mdash; это объявление переменной
				</p>
				<p>
					во&nbsp;второй строке указано объявление и&nbsp;присваивание
				</p>
				<p>
					в&nbsp;третьей строке присутствует только присваивание. Так как значение
					было присвоено ранее, третья строка -
					это
					выражение, которое возвращает значение.
				</p>

			</section>

			<section class="section">
				<h2>Выражения.</h2>
				<p>Выражение всегда возвращает значение</p>
			</section>

			<section class="section">
				<h2>
					Типы переменных в&nbsp;JS.
				</h2>
				<p>
					Тип переменной определяется типом присвоения значения. <br>
					То&nbsp;есть, например, при const a = 10&nbsp;а будет являться числом.
					const b = &rsquo;abc&rsquo; b&nbsp;будет строкой.
				</p>
				<p>
					Переменные по&nbsp;типу делятся на&nbsp;<b>ПРИМИТИВНЫЕ ТИПЫ</b>
					и&nbsp;<b>ССЫЛОЧНЫЙ
						ТИП</b>
				</p>
				<p>Переменная имеет значение. <br> Значение имеет тип. <br> Соответственно,
					переменная имеет тип.</p>
				<h3><b>Примитивные типы:</b></h3>
				<ul>
					<li>
						string
					</li>
					<li>
						boolean
					</li>
					<li>
						number
					</li>
					<li>
						null
					</li>
					<li>
						undefined
					</li>
					<li>
						symbol
					</li>
				</ul>
				<h3><b>Ссылочный тип один&nbsp;&mdash; Object, то&nbsp;есть состоит
						из&nbsp;ключа и&nbsp;значения.</b></h3>
				<p>
					При ссылочном типе переменная хранит в&nbsp;памяти только ссылку
					на&nbsp;объект, который может храниться где
					угодно.
					<br>
					Аналогичнопеременная будет со&nbsp;ссылочным типом, если
					её&nbsp;ключ&nbsp;&mdash; это массив (<b>Массив
						является объектом</b>).
				</p>
				<h4>Примеры ссылочных типов:</h4>
				<p>
					0&times;3151 {<br>
					a:10,<br>
					b: true<br>
					} <br>
					0&times;3757 [1, 2, 3]
				</p>
				<p>
					Несколько переменных могут ссылаться на&nbsp;одну переменную, поэтому при
					изменении свойств ссылки меняются
					все
					объекты, которые на&nbsp;неё ссылаются.
				</p>
				<p>
					Можно копировать переменные, задав новую переменную таким образом: <br>
					<code>
						const objectA = { <br>
						a: 10, <br>
						b: true <br>
						} <br><br>
						const copyOfA = objectA
					</code>
				</p>
				<b>ВАЖНО: доступ к&nbsp;тому или иному объекту возможен с&nbsp;помощью
					оператора &laquo;.&raquo; то&nbsp;есть
					с&nbsp;помощью точечной записи
					мы&nbsp;можем поменять свойство объекта.</b>
				<code>copyOfA.a = 20</code>
				<p>
					Если мы&nbsp;<b>меняем свойство объекта через одну из&nbsp;ссылок</b>,
					свойство поменяется для других ссылок,
					использующих
					эту переменную.
				</p>
				<p>
					Если мы&nbsp;<b>присваеваем новое свойство объекта</b>, свойство
					так&nbsp;же будет определено для всех
					переменных,
					использующих ссылку.
				</p>
				<h3>Пример:</h3>
				<code>copyOfA.c = 'abc'</code>
				<strong>Важно: Если мы&nbsp;присваиваем переменной значение типа
					&laquo;Object&raquo;, переменная хранит только
					ссылку на&nbsp;такой
					объект.</strong>
			</section>

			<section class="section">
				<h2>
					Динамическая типизация
				</h2>
				<p>

				</p>
				<b>Пример статической типизации (не&nbsp;относится к&nbsp;языку JS):</b>
				<code>
					String a = 'abc' <br>
					int b = 10 <br>
					b = 'xyz' // Error
				</code>

				<b> В&nbsp;JS&nbsp;нет надобности указывать тип переменной, достаточно
					её&nbsp;задать через var/let, потому что
					это динамически
					типизируемый язык.<br>Примеры динамической типизации в&nbsp;JS:</b>
				<code>
					let a = 10 <br>
					a = true<br>
					a = 'Demian'<br>
					a = undefined<br>
				</code>
				<code>
					function a() { <br>
					console.log('Hey there')<br>
					<br>
					}<br>

					a()// 'Hey there'<br>

					a = 10<br>
					a() //Uncaught TypeError: a is not a function
				</code>
			</section>

			<section class="section">
				<h2>Функции</h2>
				<p>
					Функци объявляются с&nbsp;помощью ключевого слова function(см. пример
					выше). <br>
				</p>
				<p>
					const лучше использовать всегда для присваивания значения переменной, так
					как это позволяет предотвратить
					возможные проблемы, связанные с&nbsp;динамической типизацией.
				</p>
				<p>
					Чтобы избежать ошибки в&nbsp;примере, указанном ранее, стоит использовать
					другой синтаксис&nbsp;&mdash;
					стрелочную функцию:
				</p>
				<code>
					const a = () => { <br>
					console.log('Hey there') <br>
					a () // 'Hey there' <br>
					a = 10 // TypeError: Assigment to constant variable <br>
					}
				</code>
				<h3>В&nbsp;этом примере стрелочной функцией будет являться</h3>
				<code>
					() => { <br>
					console.log('Hey there') <br>
					}
				</code>
				<p>
					Для объявления функции лучше использовать стрелочные функции
					и&nbsp;присваивать их&nbsp;переменным,
					объявленным с&nbsp;помощью
					const
				</p>
				<p>
					<strong>
						Так как JS&nbsp;&mdash; это динамически типизируемый язык, тип переменной
						не&nbsp;указывается, когда
						переменная объявляется.
						<br><br>
						Нужно использовать const, а&nbsp;так&nbsp;же нужно следить за&nbsp;тем,
						чтобы значения переменных
						не&nbsp;переприсваивались и&nbsp;не
						меняли свои типы.
					</strong>
				</p>
				<strong id="functions">Функция&nbsp;&mdash; это блок кода, который можно
					выполнять многократно.
					(//*187)</strong>
				<p>
					Если блоки кода в&nbsp;функции повторяются, такой код лучше оптимизировать
					(//*199).
				</p>
				<h3>Функция может быть:</h3>
				<ul>
					<li>
						именованной
					</li>
					<li>
						присвоена переменной
					</li>
					<li>
						анонимной (не&nbsp;иметь имени)
					</li>
					<li>
						аргументом при вызове другой функции (callBack function)
					</li>
					<li>
						значением свойства (метода) объекта
					</li>
				</ul>
				<p>
					Так как функция в&nbsp;JS- это объект, то&nbsp;с&nbsp;помощью метода dir
					можно посмотреть её&nbsp;свойства.
				</p>
			</section>

			<div id="objects" class="section">
				<h2>
					Объекты
				</h2>
				<p>
					Объект&nbsp;&mdash; это набор свойств &laquo;ИМЯ: ЗНАЧЕНИЕ&raquo;
				</p>
				<h3>
					Объект&nbsp;&mdash; это:
				</h3>
				<ul>
					<li>ТИП ЗНАЧЕНИЙ</li>
					<li>ТИП ПЕРЕМЕННЫХ</li>
					<li>ССЫЛОЧНЫЙ ТИП</li>
				</ul>
				<p>
					<u>Порядок свойств в&nbsp;объекте не&nbsp;имеет значения.</u> (//*26)
				</p>
				<p>
					<strong>
						Для удаления свойств используется оператор &laquo;delete&raquo; (//*37)
					</strong>
				</p>
			</div>

			<section class="section">
				<h2>
					Глобальные объекты.
				</h2>
				<ul>
					<li>
						window (присутствует в&nbsp;WEB-браузере)
					</li>
					<li>
						global (используется в&nbsp;NodeJS)
					</li>
					<li>globalThis (это <strong>унифицированный глобальный объект</strong>
						)</li>
				</ul>
				<p>
					Перейти к&nbsp;любому свойству глобальных объектов можно так&nbsp;же
					с&nbsp;помощью точечной записи.
				</p>
			</section>

			<section class="section">
				<h2>Методы.</h2>
				<p>
					Метод&nbsp;&mdash; это свойство объекта, значение которого&nbsp;&mdash;
					это функция. (//*90)
				</p>
				<p>
					<b>Для вызова метода после его точечной записи нужно поставить
						&laquo;()&raquo;.</b>
				</p>
			</section>

			<section class="section">
				<h2>
					JSON.
				</h2>
				<strong>
					JSON (JAVASCRIPT OBJECT NOTATION)&nbsp;&mdash; это формат обмена данными
					между компьютерами.
				</strong>
				<p>
					Свойства в&nbsp;JSON пишутся в &laquo;...&raquo; в&nbsp;виде строки.
				</p>
				<p>
					Чтобы конвертировать JSON в&nbsp;JS, используется метод <b>JSON.parse()</b>
					<br>
					Обратная функция&nbsp;&mdash; метод <b>JSON.stringify()</b> (2:22:22) <br>
					Пример:
				</p>
				<code>
					const post = { <br>
					///////// <br>
					} <br>
					JSON.stringify(post) <br>
					const postStringified = JSON.stringify(post) <br>
					JSON.parse(postStringified)
				</code>
			</section>

			<section class="section">
				<h2>
					Мутация в&nbsp;JS.
				</h2>
				<p>
					Рассмотрим, как копируются значения примитивных типов. (//*109)
				</p>
				<p>
					<b>Важно:</b> при изменении копии, меняется и&nbsp;исходный объект, так
					как они оба ссылаются на&nbsp;одни
					и&nbsp;те&nbsp;же
					значения.
				</p>
				<p>
					внутри функции <b>не&nbsp;рекомендуется</b> мутировать <b>внешние</b>
					объекты.(//*246)
				</p>
				<h3>Как избежать мутаций.</h3>
				<p>
					Чтобы избежать мутаций, можно использовать несколько методов:
				</p>
				<ul>
					<li>
						<h3>1. Object.assign (//*141)</h3>
						<p>
							<br>Использование <b>метода assign</b>, который является методом объекта
							Object.
							<br>С&nbsp;помощью этого метода можно задавать новые значения.
							<br>Так как Object является свойством глобального объекта,
							он&nbsp;доступен как в&nbsp;ВЕБ , так
							и&nbsp;в&nbsp;JS.
							<br>Помимо этого, Object является и&nbsp;<b>типом</b>,
							и&nbsp;<b>классом</b>,
							поэтому пишется
							с&nbsp;большой буквы.
							<br>Он&nbsp;является прототипом всех объектов в&nbsp;JavaScript
							(о&nbsp;<b>прототипах</b>
							позже).
							<br><b>Если у&nbsp;объекта есть вложенные объекты, то&nbsp;ссылки
								на&nbsp;них <u>сохраняются</u></b>.
						</p>
					</li>
					<li>
						<h3>2. Оператор... ({...person}//*159) </h3>
						<p>
							<b>...</b> используется для разделения объектов на&nbsp;свойства.
							<br><b>Если у&nbsp;объекта есть вложенные объекты, то&nbsp;ссылки
								на&nbsp;них так&nbsp;же
								<u>сохраняются</u></b>.
						</p>
						<p>Если создать копию объекта и в ней после ... указать новое свойство,
							оно будет добавлено. Если такое
							свойство в начальном файле уже существует, оно будет перезаписано (при
							указании ... перед свойством). <br>
							Если указать ... после свойства в копии, то будет перезаписано свойство
							в копии (на то, которое указано в
							начальном объекте).(//*324-348)</p>
						<p>Помимо этого с помощью <b>...</b> можно объединять
							объекты(//*353-368)</p>
					</li>
					<li>
						<h3>3. Двойная конвертация
							(JS&mdash;&gt;JSON.stringify&mdash;&gt;JSON.parse //*172) </h3>
						<p>
							<br><b>Ссылки на&nbsp;вложенные объекты при этом
								способе&nbsp;<u><b>НЕ</b>
									сохраняются</u></b>.
						</p>
					</li>
					<li>
						<h3>Пример функции:</h3>
						<code>
							function myFn(a, b) {
							let c
							a = a + 1
							c = a + b
							return c
							}
						</code>
						<p>myFn - это имя функции </p>
						<p>a, b - это параметры. Параметры - это переменные, которые действуют
							только внутри функции.</p>
						<p>{ <br>
							let c <br>
							a = a + 1 <br>
							c = a + b <br>
							return c <br> - это тело функции.
							}</p>
						<p><b>ВАЖНО:</b> при вызове функции с инструкцией "return" функция
							прекращает выполнение дальнейших
							инструкций.</p>
						<strong>Если функция не имеет инструкцию return в теле, то она возвращает
							результат undefined</strong>
					</li>
					<p><strong>Параметры - это переменные, которые действуют только внутри
							функции. <br>
							Аргументы - это те значения, которые мы передаём в вызове
							функции.</strong></p>
					<p>Аргементы меняются каждый раз при вызове функции, параметры - НЕ
						МЕНЯЮТСЯ.</p>
				</ul>
			</section>

			<section class="section">
				<p>
					Пример создания копии объекта для избежания мутирования внутри функции
					можно посмотреть в примере (//*246)
				</p>
			</section>

			<section class="section">
				<h2><b>callback функции</b></h2>(//*263)
				<p>
					В примере мы написали функцию, затем написали функцию, параметром которой
					является первая функция.
					Таким образом, вторая функция вызывает внутри себя другую функцию и
					является callback функцией.
				</p>
			</section>

			<section class="section">
				<h2>Правила работы с&nbsp;функциями:</h2>
				<ol>
					<li>Называем функции исходя из&nbsp;выполняемых задач</li>
					<li>Одна функция должна выполнять одну задачу</li>
					<li>Не&nbsp;рекомендуется изменять внешние относительно функции
						переменные</li>
				</ol>
			</section>

			<section class="section">
				<h2>Области видимости</h2>
				<p>Область видимости определяет границы действия переменной.</p>
				<p>Глобальные области видимости&nbsp;&mdash; это window или global</p>
				<p>Мы&nbsp;можем создавать локальные области видимости.</p>
				<p>Переменные в&nbsp;локальной и&nbsp;глобальной области
					видимости&nbsp;&mdash; это разные переменные, даже если
					имеют одинаковое
					название.</p>
				<p><b>Пример указан (//*281)</b></p>
				<p>Если мы&nbsp;объявляем функцию внутри другой функции, то&nbsp;при вызове
					вложенной функции в&nbsp;глобальной
					области мы
					получим ошибку. (//*299)</p>
				<p>После вызова функции внутри другой функции значения вложенной функции
					удаляются, потому что она выполняет
					своё предназначение.</p>
				<p>Если значение присваивается в&nbsp;глобальной переменной (3:33:00),
					то&nbsp;при console.log(a)
					мы&nbsp;получим то&nbsp;значение, которое получили в&nbsp;этой глобальной
					переменной (при условии, что внутри
					этой функции а&nbsp;не&nbsp;объявлялась, а&nbsp;значение было присвоено.
					Такой способ крайне&nbsp;НЕ
					рекомендуется.).</p>
				<h3>Типы областей видимости:</h3>
				<ul>
					<li>Глобальная область </li>
					<li>область видимости функции</li>
					<li>область видимости блока (переменные, объявленные с помощью let и const
						внутри блока имеют область
						видимости, ограниченную этим блоком)</li>
				</ul>
			</section>

			<section class="section">
				<h2>Правила работы с переменными:</h2>
				<ol>
					<li>Все переменные объявлять перед их использованием</li>
					<li>стараться использовать const везде, где возможно</li>
					<li>Внутри функций не менять переменные с внешних областей видимости.
						(внутри функции объявлять переменные,
						которые необходимы для выполнения функции.)</li>
				</ol>
				<p>Для выполнения последнего правила рекомендовано использовать <b>строгий
						режим или strict mode - инструкцию
						для JS анализировать код более пристально, добавив строку перед
						'use strict' функцией. Этот метод запрещает
						использование необъявленных переменных.(//*312)</b></p>
			</section>

			<section class="section">
				<h2>Основные операторы</h2>
				<p>
					Оператор - это встроенная в JS функция, поэтому она так же, как и любая
					функция, совершает действие и
					возвращает результат.
				</p>
				<p>
					Далее речь пойдёт об:
					<ul>
						<li>операторах</li>
						<li>операндах</li>
						<li>унарных и бинарных операторах</li>
					</ul>
					<ul>
						<h3>записях:</h3>
						<li>инфиксной</li>
						<li>префиксной</li>
						<li>постфиксной</li>
					</ul>
					<h3>Арифметические операторы</h3>
					<ul>
						<li>+</li>
						<li>-</li>
						<li>*</li>
						<li>/</li>
					</ul>
					<h3>Операторы сравнения</h3>
					<ul>
						<li>===</li>
						<li>!==</li>
						<li>
							<= </li>
						<li> >= </li>
					</ul>
					<h3>Логические операторы</h3>
					<ul>
						<li>! НЕ
							<p>Чаще всего используется в условных инструкциях (if / if else). <br>Он
								является булиевым.
								<br>Двойное отрицание позволяет проверить истинность (если возвращает
								false, то и начальное значение было
								false). значения 0 / undefined / '(пустая строка)' всегда возвращают
								false, поэтому при двойном отрицании
								эти значения всегда будут возвращать false. Пустой объект при двойном
								отрицани вернёт true
							</p>
						</li>
						<li>&& И
							<p>
								"И" - это бинарный оператор, при котором оба операнда должны быть
								истинными. Если первый операнд
								ложный, то дальше интерпритатор не рассматривает второе выражение.
							</p>
						</li>
						<li>|| ИЛИ
							<p></p>
						</li>
						<li></li>
					</ul>
					<h3>Оператор присваивания - "="</h3>
				</p>
				<h3>Текстовые операторы:</h3>
				<ul>
					<li>typeof Проверяет тип объекта</li>
					<li>instanceof Проверяет принадлежность объекта к тому или иному
						классу</li>
					<li>new</li>
					<li>delete Удаляет свойство в объекте</li>
				</ul>
				<h3>Операнды - это то, что находится по разные стороны от оператора. a = 10
					а и 10 - это операнды</h3>
				<strong>Оператор - это встроенная (внутренняя) функция.</strong>
				<h3>Унарные операторы</h3>
				<p>У унарных операторов всегда один операнд</p>
				<p>Примеры: <br>
					<code>
						a++
						+a
						delete obj.a
						typeof a
						new Object()
					</code>
				</p>
				<h3>Бинарные операторы</h3>
				<p>У бинарных операторов всегда два аргумента (два операнда). Пример:</p>
				<code>
					a = 5
					a + b
					a += 5
					a === b
					a && b
				</code>
			</section>

			<section class="section">
				<h2>Инфиксная запись</h2>
				<p>В таком формате записи оператор находится между операндами (a = true / a
					+ b / a || b)</p>
				<h2>Префиксная запись</h2>
				<p>++a / delete obj.a / typeof a</p>
				<h2>Постфиксная запись</h2>
				<p>a++ / myFunction()</p>
			</section>

			<section class="section">
				<h2>Приоритетность операторов (4:00:00)</h2>
				<p>Если мы хотим поменять приоритетность операторов, это делается так же,
					как и при выражениях в школьной
					программе.</p>

			</section>

			<section class="section">
				<h2>Ложные значения</h2>
				<p>Ложными значениями у булиевых типов будут: <br>
					<ul>
						<li>false</li>
						<li>0</li>
						<li>undefined</li>
						<li>null</li>
						<li>' ' любая строка будет истинным значением при возврате булиевой
							функции.</li>
					</ul>
				</p>
			</section>

			<section class="section">
				<p>Если мы хотим сравнить по типу:</p>
				<code>
					typeof 10 === 'number'
				</code>
			</section>

			<section class="section">
				<h2>Переменные в конкатенации строк.(//*373)</h2>
				<p>Чтобы не следить за тем, где ставятся пробелы, особенно если переменных
					слишком много, используются
					<b>шаблонные строки</b>.(//*379)
				</p>
				<p>чтобы получить строку с выражением, в косых кавычках (``) указываются
					`${переменные} ${с пробелом между ними
					(или без при надобности)}`</p>
			</section>

			<section class="section">
				<h2>Функциональные выражения</h2>
				<h3>Объявленная функция(//*397)</h3>
				<p>Имеет имя.</p>
				<p>Объявленную функцию можно использовать где угодно в коде.</p>

				<h3>Функциональное выражение(//*)</h3>
				<p>Функциональные выражения не имеют имени, следовательно, они всегда
					<b>АНОНИМНЫЕ</b>.
				</p>
				<p>Функциональное выражение нельзя использовать автономно.</p>
				<br>

				<p>Объявленную функцию и функциональное выражение <strong>можно присваивать
						переменной</strong> и <strong>можно
						использовать как аргумент в вызове другой функции, то есть быть callback
						function</strong>.</p>
				<p></p>
			</section>

			<section class="section">
				<h2>Пример использования функционального выражения в вызове другой
					функции(//*414)</h2>

			</section>

			<section class="section">
				<h2>Стрелочные функции</h2>
				<p>У стрелочной функции нет названия (она анонимная).(//*422)</p>
				<p>Стрелочная функция - это <b>ВЫРАЖЕНИЕ</b>, следовательно, они анонимные
					ВСЕГДА.</p>
				<p>Чтобы дать имя стрелочной функции, нужно присвоить её в качестве
					значения переменной. <br>
					Если переменная объявляется через const, переприсвоить значение переменной
					будет нельзя. <br>
					Если объявлять переменную через ключевое слово function, значение можно
					будет переприсвоить.(//*431)</p>
				<h3>Способы сокращения стрелочных функций.</h3>
				<ul>
					<li>Если у стрелочной функции один параметр, допустимо опустить
						скобки.(//*447)</li>
					<li>Так же скобки можно опустить, если стрелочная функция состоит из
						одного выражения (если она неявно
						возвращает результат выражения)(//*452).</li>
				</ul>
			</section>

			<section class="section">
				<h2>Значения параметров функции по умолчанию.(//*458)</h2>
				<p>Если мы хотим установить значение параметра по умолчанию, мы указываем
					его прямо рядом с аргументом функции через "=".</p>
				<h3>Пример значения функции по умолчанию в стрелочной функции,
					предназначенной для добавления свойства(//*471-482).</h3>
				<p>Чтобы вернуть неявно объект без использования return, мы должны обернуть
					тело функции в круглые скобки</p>
			</section>

			<section class="section">
				<h2>
					Что происходит в случае ошибок:
				</h2>
				<code>
					const fnWithError = () => {
					throw new Error('Some error')
					}
					fnWithError() // здесь код прекратит выполнение

					console.log('Continue...')
				</code>
				<p>Помочь в решении вопроса поможет метод try/catch, он состоит из двух
					блоков кода. Часть кода, в котором возможна ошибка, мы помещаем в первый
					блок кода try.
					<br> Если ошибка отловлена в первой части, начинает выполняться второй
					блок кода catch:
				</p>
				<code>
					try {
					//выполнение блока кода
					} catch (error) {
					// Этот блок выполняется в случае возникновения ошибок в блоке try
					}
				</code>
				<p>Пример:</p>
				<code>
					const fnWithError = () => { <br>
					throw new Error('ОПАНЬКИ!') <br>
					} <br>
					<br>
					try { <br>
					fnWithError() <br>
					} catch (error) { <br>
					console.error(error) //Эта строка описывает полный текст ошибки, её можно
					не указывать, если достаточно просто текста, заданного для message
					console.log(error.message) <br>
					} <br><br>
					console.log('Continue...') при использовании
				</code>
			</section>

			<section class="section">
				<h2>Инструкции, выражения, выражения-инструкции.</h2>
				<p>Самый доступный пример инструкции - это объевление переменной с помощью
					ключевого слова let.</p>
				<p>Если выражение всегда выполняет значение, то <b>инструкция всегда
						выполняет определённое действие</b>. <br>
					каждую инструкцию следует завершать ";", если инструкций несколько,
					рекомендовано размещать их с пропуском строки. Пример (//*440) <br>
					";" не требуется после блока инструкции.</p>
				<h3>Пример выражения инструкции: (//*454)</h3>
				<strong>Все объявления переменных с ключевыми словами let/const - это
					инструкции в JS.</strong>
				<p>Инструкция не может быть трансформирована в выражение.</p>
			</section>

			<section class="section">
				<h2>Массивы.</h2>
				<p>Массив - это объект с цифровыми именами свойств.(//*470)</p>
				<p>Структура массивов.(//*478)</p>
			</section>

			<section class="section">
				<h2>Методы массивов(//*500).</h2>
				<ul>
					<li>push <br>
						<code>

						</code>
					</li>
					<li>pop<br>
						Этот метод позволяет убрать последний элемент из массива. <br>
						Если присвоить функции название (сделать переменную), можно будет вывести
						удалённый элемент массива. <br>
						<code>
							const myArray = [1, 2, 3, 4, 5] <br>
							const rem = myArray.pop() <br>
							const poppedElemOfmyArray = myArray <br>
							console.log(poppedElemOfmyArray) <br>
							console.log(myArray) <br>
							console.log(rem) <br>
						</code>
					</li>
					<li>unshift <br>
						Добавляет элемент в начале массива.
						<code>
							const myArray = [1, 2, 3] <br>
							console.log(myArray) // [1, 2, 3] <br>

							myArray.unshift(true) <br>

							console.log(myArray) // [true, 1, 2, 3] <br>

							myArray.unshift('abc') <br>

							console.log(myArray) //['abc', true, 1, 2, 3] <br>
						</code>
					</li>
					<li>shift <br>
						Удаляет первый элемент массива по аналогии с pop
						<br><br>
					</li>
					<li>forEach <br>
						<code>
							const myArray = [1, 2, 3] <br>
							console.log(myArray) //[1, 2, 3] <br>
							<br>
							myArray.forEach(el => console.log(el * 2)) <br>
							<br>
							console.log(myArray) //[1, 2, 3] ориг. массив не изменился <br>
						</code>
						<p>ничего не возвращает</p>
					</li>
					<li>map <br>
						<code>

						</code>
					</li>
					<li>reduce <br>
						<code>

						</code>
					</li>
					<li>и прочие...</li>
				</ul>
				<p>
					Первые 4 метода массивов мутируют объекты, несмотря на то, что массив из
					примера объявлен через const.
					Это возможно, потому что массив - это ссылочный тип объекта, а сама
					переменная сохраняет только ссылку на объект.
				</p>
				<p>
					Методы массивов называются функциями высшего порядка в массивах.
				</p>
			</section>

			<section class="section">
				<h2>Деструктуризация.</h2>
				<p>
					С помощью деструктуризации в JS можно создать новые переменные и присвоить
					им значения в одной строке.(//*555)
				</p>
			</section>

			<section class="section">
				<h2>Условные инструкции.(//*600)</h2>
				<ul>
					<li>
						<h3>if</h3>
						<p>
							При этой инструкции блок кода выполняется однократно, если условие
							правдиво.
						</p>
						<p>Отличный пример использования представлен в примере (//*680-693)</p>
					</li>
					<li>
						<h3>if...else</h3>
						<p>
							В этой инструкции выполняется только один из блоков.
						</p>
					</li>
					<li>
						<h3>if... else if ... else</h3>
						<p>
							Здесь мы можем писать длинные цепочки условий.
						</p>
					</li>
					<li>
						<h3>switch</h3>
						<p>
							Используется, если нужно рассмотреть несколько кейсов и выбрать из них
							подходящий. Пример: <br>
						</p>
						<code>
							switch (выражение) {<br>
							case A: <br>
							//действия если выражение === А <br>
							break <br>
							case B: <br>
							// <br>
							break <br>
							default: <br>
							// Действия по умолчанию <br>
							} <br>
						</code>
					</li>
					<li>
						<h3>Тернарный оператор</h3>
						<p>
							используется в выражениях. Выражения возвращают результат (значение).
							<br>
							У тернарного оператора три операнда. <br>
							Синтаксис у тернарного оператора такой:

							<b>Условие</b>
							? <b>Выражение 1</b>
							: <b>Выражение 2</b> <br>

							где: <br>
							<b>Условие</b> - это любое выражение ; <br>
							<b>Выражение 1</b> - это выражение, результат которого возвращается,
							если <b>Условие</b> правдиво; <br>
							<b>Выражение 2</b> - это выражение, результат которого возвращается,
							если <b>Условие</b> ложно. <br>
							Пример (//*730, *738)
						</p>
					</li>
				</ul>
			</section>

			<section class="section">
				<h2>Циклы(Введение в циклы)</h2>
				<p>
					Все циклы - это инструкции.
					<br> Во всех циклах блок кода выполняется многократно, зависимо от
					количества итераций.
				</p>
				<h3>Типы циклов:</h3>
				<ul>
					<li>for
						<p>Можно, но не рекомендуется использовать для массивов. Для
							массивов лучше использовать функции высшего порядка
							"forEach/map/reduce"</p>
					</li>
					<li>for...in...</li>
					<li>while</li>
					<li>do...while</li>
					<li>for...of...</li>
				</ul>
			</section>

			<div>
				<h3>Цикл for (Пример //*750)</h3>
				<code>
					for (начальная инструкция; Условие; Итерационное действие) { <br>
					Блок кода, выполняемый на каждой итерации <br>
					} <br>
				</code>
			</div>

			<h3>
				Метод массивов <strong>foreach</strong>
			</h3>
			<code>
				const myArray = ['first', 'second', 'third'] <br>
				<br>
				myArray.forEach((element, index) => { <br>
				console.log(element, index) <br>
				}) <br>
				<br>
				// 'first' <br>
				// 'second' <br>
				// 'third' <br>
			</code>
			<p>С помощью forEach мы можем получать доступ непосредственно к элементам
				массива, а так же к индексу определённого элемента. При использовании
				используется точечная запись.
				В этом методе мы должны указать callback функцию столько раз, сколько
				элементов в массиве.
				Если нам не нужен индекс, мы можем оставить в этом методе только один
				элемент.</p>

			<h3>
				Метод массивов <strong>while</strong>
			</h3>
			<p>Позволяет выполнять блок кода, пока условие правдиво.</p>
			<code>
				while (Условие) { <br>
				//Блок кода, выполняемый на каждой итерации <br>
				} <br>
				<br>
				//Пример: <br>
				let i = 0 <br>
				while (i < 5) { <br>
				console.log(i) <br>
				<strong>i++</strong>// если не указать эту строку, цикл будет выполняться
				<br>
				бесконечно. <br>
				} <br>
			</code>

			<h3>
				Метод массивов <strong>do while</strong>
			</h3>
			<p>
				Можно расшифровать как "Делать действие, пока условие правдиво".
			</p>
			<code>
				do { <br>
				// Блок кода, выполняемый на каждой итерации (выполняется хотя бы 1 раз)
				<br>
				} while (Условие) <br>
				<br>
				//Пример: <br>
				let i = 0 <br>
				do { <br>
				console.log(i) <br>
				i++ <br>
				} while (i < 5) <br>
			</code>

			<h3>
				Метод <strong>for in</strong> для объектов.
			</h3>
			<p>
				При таком методе получить доступ к свойству мы можем с помощью []
			</p>
			<code>
				for (key in Object) { // дословно это ключ в объекте (под объектом
				подразумеваем переменную).<br>
				// Действия с каждым свойством объекта <br>
				// Значения свойства - Object[key]. Здесь мы через [] получаем доступ к
				свойству объекта<br>
				} <br>
				// Пример: <br>
				<br>
				const myObject = { <br>
				x: 10, <br>
				y: true, <br>
				z: 'abc', <br>
				} <br>
				for (const key in myObject) { <br>
				console.log(key, myObject[key]) <br>
				} <br>
			</code>

			<h3>
				Метод массивов <strong>forEach</strong>
			</h3>
			<p>
				Перебрать все свойства объекта можно c помощью конструкции Object.keys() -
				эта конструкция даст нам массив свойств. Затем с помощью метода свойств
				forEach мы можем перебрать свойства этого массива.
			</p>
			<code>
				const myObject = { <br>
				x: 10, <br>
				y: true, <br>
				z: 'abc' <br>
				} <br>
				<br>
				Object.keys(myObject).forEach(key => { <br>
				console.log(key, myObject[key]) <br>
				}) <br>
				<br>
				//или с помощью forEach можно перебирать сразу значения свойств объекта:
				<br>
				const myObject = { <br>
				x: 10, <br>
				y: true, <br>
				z: 'abc' <br>
				} <br>
				<br>
				Object.values(myObject).forEach(value => { <br>
				console.log(value) <br>
				}) <br>
			</code>
			<p>Методы .keys и .values можно комбинировать.</p>
			<p>
				<strong>С помощью методов Object.keys и Object.values можно
					трансформировать объект в массив свойств или в массив
					значений.</strong>
			</p>

			<h3>Цикл <strong>for in</strong> для массивов</h3>
			<p>Этот цикл можно использовать не только для объектов, но и для
				массивов.</p>
			<code>
				const myArray = [true, 10, 'abc', null] <br>
				<br>
				for (const key in myArray) { <br>
				console.log(myArray[key]) <br>
				} <br>
			</code>
			<p>В этом примере на каждом этапе итерации будет создаваться абсолютно новая
				переменная key (так как используется const)</p>
			<p><strong>Так делать НЕ рекомендуется. Для этого у массивов есть
					собственные методы.</strong></p>

			<h3>Цикл for of </h3>
			<p><strong>ВАЖНО: FOR OF не подходит для Object, потому что объект не
					является итерируемым.</strong></p>
			<code>
				for (Element of Iterable) { // Iterable - в этом примере - это любая
				переменная, элементы которой можно перебирать (итерироваться, например,
				строка и её символы). <br>
				// Действия с определённым элементом <br>
				} <br>
				<br>
				//Пример (для строк): <br>
				const myString = 'Hey' <br>
				<br>
				for (const letter of myString) { //letter - это каждый символ строки. <br>
				console.log(letter) <br>
				} <br>
				//H <br>
				//e <br>
				//y <br>
				<br>
				//Пример 2 (для массивов): <br>
				const myArray = [true, 10, 'abc', null] <br>

				for (const element of myArray) { <br>
				console.log(element) <br>
				} <br>
			</code>

			<h3><strong>Резюмируем:</strong></h3>
			<p>
				Так как самые популярные конструкции в JS - это массивы и объекты, нам нужно
				понимать, как они перебираются. <br>
				Для массивов есть такие методы, как forEach, .map, indexOf и прочие. <br>
				Для объектов есть возможность конвертации объектов в массив с помощью
				Object.keys (для получения массива свойств объекта) <br>
				и <br>
				Object.values для получения массива значений свойств объекта. <br>
				При этом, после получения массивов и в том и в другом случае мы можем после
				получения массивов работать с ними с помощью методов для массивов.
			</p>

			<section class="section">
				<h2>Модули</h2>
				<p>
					Модули позволяют структурировать код. <br>
					Так же они позволяют избегать дублирования блоков кода. <br>
					export/import используется для переиспользования модулей, когда каждый файл
					проекта является отдельным модулем.
				</p>
				<h3>пример экспорта и импорта для условных moduleOne.js moduleTwo.js, где из
					первого модуля мы экспортируем значение функции во второй файл:</h3>
				<code>
					//moduleOne.js <br>
					const myName = () => { <br>
					console.log('Demian') <br>
					} <br>
					export default myName <br>
					<br>
					//moduleTwo.js <br>
					import printMyName from './moduleOne.js' // расширение .js можно опускать.
					<br>
					printMyName() //Demian <br>
				</code>
				<p>В примере нет ошибки, имена функции в файлах могут не совпадать.
				</p>
				<p>
					B NODE используется другой синтаксис импорта и экспорта. В его синтаксисе
					используются ключевые слова require и module.exports
				</p>
				<p>Переменная, которая находится в одном конкретном модуле, находится в зоне
					видимости этого модуля и <strong>недоступна в других модулях</strong>
				</p>
				<p>
					Теперь пример <strong>нескольких экспортов</strong>:
				</p>
				<code>
					//moduleOne <br>
					const one = 1 <br>
					const two = 'two' <br>
					<br>
					export { <br>
					one, <br>
					two <br>
					} <br>
					<br>
					<br>
					//moduleTwo <br>
					import { <br>
					one, <br>
					two <br>
					} from './moduleOne.js' <br>
					<br>
					console.log(one) // 1 <br>
					console.log(two) // two <br>
				</code>
				<p>
					При таком способе экспорта названия переменных обязательно должны совпадать
					в первом и втором модулях.
				</p>
				<p>
					При этом способе мы можем при импорте переименовать во втором модуле
					переменную с помощью <strong>"as":</strong>
				</p>
				<code>
					//moduleOne <br>
					const one = 1 <br>
					const two = 'two' <br>
					<br>
					export {one, two} <br>
					<br>
					//moduleTwo <br>
					import { <br>
					one as oneRenamed <br>
					two <br>
					} from './moduleOne.js' <br>
					<br>
					console.log(oneRenamed) //1 <br>
					console.log(two) // 'two' <br><br>
				</code>
				<h3>Правила работы с модулями:</h3>
				<ol>
					<li>
						Модули должны быть одноцелевыми (такими, чтобы их можно было
						переиспользовать в разных файлах).
					</li>
					<li>
						Все export инструкции должны быть внизу файла.
					</li>
					<li>
						Все import инструкции должны быть сверху файла.
					</li>
					<li>
						По возможности использовать export default
					</li>
					<li>
						Если импортируются переменные из внешних библиотек, рекомендуется сперва
						прописывать эти импорты, затем из собственных модулей.
					</li>
				</ol>
			</section>
			<!-- (8:37:00) -->
			<section class="section">
				<h2>Классы и прототипы</h2>
				<h3>Синтаксис классов (появился в ES6)</h3>
				<p>
					class раньше не использовался, потому что JS не является ООЯП <br>
					С помощью классов мы можем создавать шаблоны (прототипы) для объектов,
					затем создавать
					на их основе <strong>экземпляры объектов</strong> <br>
					<br>Классы позволяют делать прототипы для объектов. <br>
					<br>На основании прототипов создаются экземпляры <br>
					<br>экземпляры наследуют свойства и методы прототипов. <br>
				</p>
				<p>Фактически, классы в JS - это лишь синтаксическая надстройка над
					функциями и объектами. <br>
					На самом деле экземпляры классов в JS создаются с помощью вызова
					функции.</p>
				<h2>
					Классы позволяют делать прототипы для объектов.
				</h2>
				<code>
					// Пример (Пояснение на 8:44:00) <br>
					class Comment { //ключевое слово НазваниеКласса<br>
					constructor(text) { //метод(опциональные параметры)<br>
					this.text = text // <br>
					this.votesQty = 0// <br>
					} <br>

					upvote() { //метод() с помощью него мы увеличиваем значение через оператор
					+=<br>
					this.votesQty += 1 <br>
					} <br>
					} <br>
				</code>
				<p><strong>this</strong> - это специальная переменная, которая указывает на
					конкретный
					экземпляр класса.</p>
				<p><strong>constructor()</strong> всегда вызывается только при создании
					нового объекта.</p>
				<strong><p>Когда мы создаём новый экземпляр такого класса, this
						автоматически будет ссылаться на такой новый экземпляр и, ссылаясь на
						конкретный экземпляр класса, мы можем внутри методов и свойств класса
						менять собственные методы и свойства такого экземпляра.</p></strong>
				<p>Чтобы создать новый комментарий, мы используем ключевое слово
					new.
				</p>
				<code>
					const firstComment = new Comment('First comment') // здесь мы с помощью
					конструктора вернем новый экземпляр объекта. <br>
					console.log(firstComment) // Comment будет прототипом такого экземпляра. //
					firstComment является экземпляром класса Comment. <br>
					<br>
					firstComment.upvote() <br>
					console.log(firstComment.votesQty) // 1 <br>
					firstComment.upvote() <br>
					console.log(firstComment.votesQty) // 2 <br>

				</code>
				<p>Цепочка прототипов будет такой: <br>
					Object --> Comment --> firstComment</p>
				<p>Чтобы проверить наследование (принадлежность экземпляра к объекту),
					используется instanceof</p>
				<code>
					firstComment instanceof Comment // true <br>
					firstComment instanceof Object // true <br>
					firstComment instanceof Array // false <br>
				</code>
				<p>Проверка принадлежности свойств экземляру объекта (собственные
					свойства):</p>
				<code>
					const firstComment = new Comment('Fisrt comment') <br><br>
					firstComment.hasOwnProperty('text') // true <br>
					firstComment.hasOwnProperty('votesQty') // true <br>
					firstComment.hasOwnProperty('upvote') // false потому что это св-во не
					является собственным <br>
					firstComment.hasOwnProperty('hasOwnProperty') // false аналогично с upvote,
					оба св-ва наследованные, а не собственные.<br>
				</code>
			</section>

			<section class="section">
				Как это применяется на практике: <br>
				<code>
					//Создаем несколько экземпляров <br>
					class Comment { <br>
					constructor(text) { <br>
					this.text = text <br>
					this.votesQty = 0 <br>
					&nbsp;} <br>
					<br>
					&nbsp;&nbsp;upvote() { <br>
					&nbsp;&nbsp;this.votesQty += 1 <br>
					&nbsp;} <br>
					} <br> <br>
					const firstComment = new Comment('Fisrt comment') <br>
					const secondComment = new Comment('Second comment') <br>
					const thirdComment = new Comment('Third comment') <br>
				</code>
				<h2>Экземпляры</h2>
				<p>Экземпляры могут иметь собственные свойства и методы.</p>
				<p>Экземпляры наследуют свойства и методы прототипов.</p>
			</section>
			<section class="section">
				<h2>Статические методы</h2>
				<p>Кроме методов, которые мы обсуждали ранее, которые доступны на уровне
					каждого экземпляра, можно на уровне классов создавать <strong>статические
						методы</strong>.
					<br>Такие методы создаются с использованием ключевого слова <i>static</i>.
					Пример:</p>
				<code>
					class Comment { <br>
					&nbsp;constructor(text) {<br>
					&nbsp;&nbsp;this.text = text <br>
					&nbsp;&nbsp;this.votesQty = 0 <br>
					&nbsp;} <br>
					<br>
					&nbsp;upvote() { <br>
					&nbsp;&nbsp;this.votesQty += 1 <br>
					} <br>
					<br>
					&nbsp;static mergeComments(first, second) { <br>
					&nbsp;&nbsp;return `${first} ${second}`<br>
					&nbsp;} <br>
					} <br>
					<br>
					Comment.mergeComments('First comment.', 'Second comment.')
				</code>
				<p> Здесь mergeComments является статическим методом. Такой метод будет
					доступен как свойство класса Comment, то есть мы сможем его вызвать таким
					способом:</p>
				<code>Comment.mergeComments('First comment.', 'Second comment.')</code>
				<p>Здесь мы не используем ключевое слово new. Мы просто вызываем
					mergeComments как метод класса Comment. <br>
					Похожим образом мы поступаем, когда вызываем такие методы, как
					Object.assign, Object.keys, Object.values (эти методы являются статическими
					методами объекта.)</p>
				<p>В этом примере метод upvote() наследуется всеми экземплярами класса
					Comment, <br>
					а mergeComments не наследуется и становится доступным только способе
					вызова, описанном в последней строке примера.</p>
			</section>

			<section class="section">
				<h2>Расширение других классов.</h2>
				<p>Здесь мы используем ключевое слово extends (рус.- расширять). <br>
					Задача этого метода будет добавлять так же метод sum, который будет
					автоматически
					суммировать все элементы любого массива. <br>
					То есть в примере мы расширяем методы Array и добавляем ещё один метод,
					который будет доступен всем массивам с используемым классом NumbersArray.
					<br>
					При такой форме записи родительский конструктор вызывается автоматически
					(Array). <br>
					Когда создаётся новый экземпляр класса NumbersArray, сначала вызывается
					конструктор родительского класса (Array) и возвращает новый объект, затем
					this будет ссылаться на новый вновь созданный экземпляр массива.
				</p>
				<code>
					class NumbersArray extends Array { <br>
					&nbsp;sum() { <br>
					&nbsp;&nbsp;return this.reduce((el, acc) => acc += el, 0) <br>
					&nbsp;} <br>
					} <br>
					<br>
					const myArray = new NumbersArray(2, 5, 7) // здесь будет создан новый
					массив с использованием конструктора родительского класса. это будет
					массив, у которого будут доступны все методы массивов (map, reduce, forEach
					и т.д.)<br>
					<br>
					console.log(myArray) <br>
					myArray.sum() <br>
				</code>
				<p>
					Таким образом, будет создан новый экземпляр (new NumbersArray), который
					будет наследовать все методы NumbersArray, который наследует все методы от
					Array. <br>
					Следовательно, метод sum будет доступен для каждого экземпляра класса
					NumbersArray. <br>
					И если мы вызовем такой метод myArray.sum(), то все элементы этого массива
					myArray будут просуммированы. <br>
					Элементы массива легко просуммировать с помощью метода reduce, который
					имеет 2 параметра - элемент <i>el</i> и аккумулятор <i>acc</i>. <br>
					<i>acc</i> - это отдельная переменная, которая может изменяться в процессе
					итерации по массиву. <br>
					То есть ((el, acc) => acc += el) будет вызвана столько раз, сколько
					элементов в массиве.
					<br> 0 - это начальное значение аккумулятора.
				</p>
			</section>

			<section class="section">
				<h2>__proto__</h2>
				<p>У каждого экземпляра того или иного класса есть скрытое свойство
					"__proto__", менять которое вручную крайне не рекомендуется. <br>
					С помощью него создаётся вся цепочка прототипов</p>
				<code>Comment.prototype === firstComment.__proto__ // true</code>
			</section>

			<section class="section">
				<h2>Promise</h2>
				<p>
					Промисы позволяют обрабатывать отложенные во времени события.
				</p>
				<p>Промис - это обещание предоставить результат позже.</p>
				<p>Промис может вернуть ошибку, если результат предоставить невозможно.</p>
				<p>У промиса есть три состояния:</p>
				<ol>
					<li>Ожидание (pending)</li>
					<li>Исполнен</li>
					<li>Отклонён</li>
				</ol>
				<code>
					const myPromise = new Promise((resolve, reject) => { <br>
					&nbsp;&nbsp;/** <br>
					&nbsp;&nbsp;*Выполнение асинхронных действий <br>
					&nbsp;&nbsp;* <br>
					&nbsp;&nbsp;*Внутри этой функции нужно в результате вызвать одну из функций
					resolve или reject <br>
					&nbsp;&nbsp;*/ <br>
					}); <br>
				</code>
				<p>Когда мы вызываем resolve, мы должны передать какой-то результат. Когда
					была вызвана функция resolve, промис считается исполненным. <br>
					Состояние pending меняется на "Исполнено". <br>
					Если же где-то возникла ошибка, мы должны вызвать другую функцию - reject,
					промис поменяет статус на "Rejected".</p>
				<h3><strong>Как получить результат промиса?</strong></h3>
				<code>
					myPromise <br>
					&nbsp;.then(value => { <br>
					&nbsp;&nbsp;/** <br>
					&nbsp;&nbsp;* Действия в случае успешного исполнения Промиса <br>
					&nbsp;&nbsp;*Значение value - это значение, переданное в вызове функции
					resolve внутри Промиса <br>
					&nbsp;&nbsp;*/ <br>
					&nbsp;}) <br>
					&nbsp;.catch(error => { <br>
					&nbsp;&nbsp;/** <br>
					&nbsp;&nbsp;* Действия в случае отклонения Промиса <br>
					&nbsp;&nbsp;* Значение error - это значение, переданное в вызове функции
					<br>
					&nbsp;&nbsp;*/ <br>
					}) <br>
					<br>
					&nbsp;.catch(error => {
					&nbsp;&nbsp;/**
					&nbsp;&nbsp;* Действия в случае отклонения Промиса
					&nbsp;&nbsp;* Значение error - это значение, переданное в вызове функции
					reject внутри Промиса.
					&nbsp;&nbsp;*/
					});
				</code>
				<p>Значение параметра value будет равняться тому значению, которое было
					передано функции resolve (результата Промиса). <br>
					То есть, на первом шаге мы создали Промис, а сейчас мы работаем с
					результатом Промиса.</p>
				<h3>Получение данных с помощью <strong>FETCH API (9:52:00)</strong>.</h3>
				<code>
					fetch('https://jsonplaceholder.typicode.com/')<br>
					&nbsp;.then(response => response.json())<br>
					&nbsp;.then(json => console.log(json))<br>
					&nbsp;.catch(error => console.error(error))<br>
				</code>
				<br>
				<p>Здесь fetch возвращает Промис и response.json() возвращает Промис. <br>
					В конце стоит метод catch, если любой из промисов будет отклонён.</p>
				<h3>Можно упростить пример, использовав только 1 промис
					(#ПримерПромиса_1):</h3>
				<code>
					const getData = (url) => <br>
					&nbsp;new Promise((resolve, reject) => <br>
					&nbsp;&nbsp;fetch(url) <br>
					&nbsp;&nbsp;&nbsp;.then(response => response.json()) <br>
					&nbsp;&nbsp;&nbsp;.then(json => resolve(json)) <br>
					&nbsp;&nbsp;&nbsp;.catch(error => reject(error)) <br>
					&nbsp;) <br>
					<br>
					getData('https://jsonplaceholder.typicode.com/todos') //Передаём url, по
					которому нужно обратиться к серверу.<br>
					&nbsp;.then(data => console.log(data)) <br>
					&nbsp;.catch(error => console.log(error.message)) <br>
				</code>
				<p>Вызов функции, в том числе, создание любого объекта - это функция,
					поэтому мы можем использовать такое выражение (создание объекта) для
					возврата его значения неявно, используя стрелочную функцию.</p>
				<p>При создании нового промиса мы передаём в качестве его аргумента новую
					функцию (с параметрами resolve, reject), и внутри этой функции вызываем
					fetch.</p>
				<p>Теперь мы не просто печатаем в консоль ошибку, а вызываем функцию
					resolve, в которой оjson (JS объект) будет аргументом, а в случае ошибки
					вызываем функцию reject и передаём ей ошибку.</p>
				<p>Таким образом, мы создали собственный промис, чтобы обернуть в неuj
					вызов, используя функцию fetch.</p>
				<p>Сперва мы получаем ответ от сервера, потом мы получаем resolve, и только
					тогда мы резолвим наш промис (получаем значение).</p>
				<p>Следовательно, теперь мы можем вызывать функцию getData(), чтобы посылать
					запросы. <br>
					Этот вызов вернёт нам Промис (new Promise). <br>
					Потом мы выполняем действия в промисе и когда он резолвится, и в случае,
					если он выводит ошибку.</p>
				<p>В этом примере получается, что на выходе new Promise возвращает нам
					только один Промис, поэтому при вызове getData у нас только один метод
					then, и значением data будет то, что мы передали в вызове функции
					resolve.<br></p>
			</section>

			<section class="section">
				<p>Таким образом, мы можем сохранить первую часть <br>
					<code>
						const getData = (url) => <br>
						&nbsp;new Promise((resolve, reject) => <br>
						&nbsp;&nbsp;fetch(url) <br>
						&nbsp;&nbsp;&nbsp;.then(response => response.json()) <br>
						&nbsp;&nbsp;&nbsp;.then(json => resolve(json)) <br>
						&nbsp;&nbsp;&nbsp;.catch(error => reject(error)) <br>
						&nbsp;) <br>
					</code>
					в качестве модуля и экспортировать её в другие модули, вызывая функцию
					getData.</p>
			</section>

			<section class="section">
				<h2>ASYNC / AWAIT - ЭТО СПЕЦИАЛЬНЫЙ СИНТАКСИС ДЛЯ УПРОЩЕНИЯ РАБОТЫ С
					ПРОМИСАМИ.</h2>
				<p>Асинхронная функция - это функция, которая вместо какого-то значения
					возвращает промис.</p>
				<p>Чтобы создать асинхронную функцию, мы добавляем ключевое слово asynс.</p>
				<p>Пример синтаксиса в стандартном объявлении функции и в callBack
					функции:</p>
				<code>
					asynс function asynсFn() {<br>
					&nbsp;return 'Success!'//Всегда возвращает Промис (в этом примере всегда
					будет исполнен, потому что мы возвращаем результат).<br>
					}
					<br><br>
					const asyncFn = async () => {<br>
					&nbsp;return 'Success!'// Всегда возвращает промис
					} <br>
					asyncFn() <br><br>
					.then(value => console.log(value)) <br><br>
					//либо <br>
					const asyncFn = async () => {<br>
					&nbsp;throw new Error('There was an error')// Всегда возвращает промис
					} <br>
					asyncFn() <br>
					.then(value => console.log(value)) <br>
					.catch(error => console.log(error.message))<br>
				</code>
				<p>async всегда ставится перед стрелочной функцией.</p>
				<figcaption>
					<img style="width: 340px; height: 350px"
						src="../Стащук/screensh/050531.png" alt="Пример 050531">
				</figcaption>
			</section>

			<section class="section">
				<h2>AWAIT</h2>
				<p>В асинхронных функциях можно использовать ключевое слово await, с помощью
					которого можно ожидать результата другого промиса.</p>
				<p>await можно использовать только внутри асинхронной функции.</p>
				<h3>Пример ожидания результата await:</h3>
				<code>
					const timerPromise = () =><br>
					&nbsp;new Promise ((resolve, reject) =><br>
					&nbsp;&nbsp;setTimeout(() => resolve(), 2000))<br>
					<br>
					const asyncFn = async () => {<br>
					&nbsp;console.log('Timer starts')<br>
					&nbsp;const startTime = performance.now()<br>
					&nbsp;await timerPromise()<br>
					&nbsp;const endTime = performance.now() <br>
					&nbsp;console.log('Timer ended', endTime - startTime)<br>
					}<br>
					asyncFn() <br>
				</code> <br>
				<p>Теперь мы можем переписать #ПримерПромиса_1 с промисов на async /
					await:</p>
				<code>
					const getData = async (url) => { <br>
					&nbsp;const res = await fetch(url) <br>
					&nbsp;const json = await res.json() <br>
					&nbsp;return json <br>
					} <br>
					<br>
					getData('https://jsonplaceholder.typicode.com/todos/58') <br>
					&nbsp;.then(data => console.log(data)) <br>
					&nbsp;.catch(error => console.log(error.message)) <br>
					<br>
					const url = 'https://jsonplaceholder.typicode.com/todos/58' <br>
					<br>
					const data = await getData(url)
					<br>
				</code>
				<p>Если закончить код на этом этапе, может возникнуть неотловленная
					ошибка.<br>
					Чтобы её избежать, нужно переписать последние строки, используя
					try/catch:</p>
				<code>
					const url = 'https://jsonplaceholder.typicode.com/todos/58' <br>
					try { <br>
					&nbsp;const data = await getData(url) <br>
					&nbsp;console.log(data) <br>
					} catch (error) { <br>
					&nbsp;console.log(error.message) <br>
					} <br>
				</code>
				<h3>Главное в ASYNC/AWAIT:</h3>
				<ol>
					<li>
						<p>ASYNC/AWAIT - это синтаксическая надстройка над промисами.</p>
					</li>
					<li>
						<p>AWAIT синтаксис возможен только внутри ASYNC функций</p>
					</li>
					<li>
						<p>ASYNC функция всегда возвращает промис</p>
					</li>
					<li>
						<p>ASYNC функция ожидает результата инструкции AWAIT и не выполняет
							последующие инструкции.</p>
					</li>
				</ol>
			</section>

			<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

			<section class="section">
				<ul>
					<li>
						<p>
							<strong>
								Функция - это блок кода, который можно выполнять многократно. <br>
								<code>
									let a = 5 <br>
									let b = 9 <br>
									<br>
									function sum(a, b) { <br>
									const c = a + b <br>
									console.log(c) <br>
									} <br>
									sum(a, b) // 14 <br>
									<br>
									a = 8 <br>
									b = 12 <br>
									<br>
									sum(a, b) // 20 <br>
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Метод&nbsp;&mdash; это
								свойство объекта, значение которого - функция.
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								JSON (JAVASCRIPT OBJECT NOTATION)&nbsp;&mdash; это формат обмена данными
								между компьютерами.
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								При изменении свойств копии объекта свойства начального объекта так же
								меняются.
								<code>
									const person = { <br>
									name: 'Bob', <br>
									age: 25 <br>
									} <br>
									<br>
									const person2 = Object.assign({}, person) <br>
									<br>
									person2.age = 29 <br>
									<br>
									console.log(person2.age) //29 <br>
									console.log(person.age) //25 <br>
									// Подходит только для объектов, у которых нет вложенных объектов <br>
									<br> <br>
									// 2 способ с использованием оператора разделения объекта на свойства
									(при изменении свойств объекта в копии меняет и свойства
									оригинального объекта)
									<br>
									{...*копируемая переменная*} : <br>
									const person2 = { ...person } <br>
									person2.name = 'Alice' <br>
									<br>
									console.log(person2.name) // Alice <br>
									console.log(person.name) // Bob <br>
									<br>
									//Как избежать мутаций: <br>
									//Отлично подойдёт двойная конвертация JSON: <br>
									const person2 = JSON.parse(JSON.stringify(person)) <br>
									person2.name = 'Alice' <br>
									<br>
									console.log(person2.name) //Alice <br>
									console.log(person.name) //Bob
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								callback функция - это функция, которая вызывается в теле другой
								функции. callbackFn всегда анонимны, они являются функциональным
								выражением. <br>
								<code>
									function anotherFn() { <br>
									// действия.... <br>
									} <br>
									<br>
									function fnWithCallback(callbackFn) { <br>
									callbackFn() <br>
									} <br>
									<br>
									fnWithCallback(anotherFn) <br><br>
								</code>
								<code>
									//Пример: <br>
									function printMyName() { <br>
									console.log('Demian') <br>
									} <br>
									<br>
									setTimeout(printMyName, 1000) <br>
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p><strong>
								Правила работы с функциями:<br>
								<ol>
									<li>Называать функции исходя из выполняемых задач</li>
									<li>Одна функция должна выполнять одну задачу</li>
									<li>Не рекомендуется изменять внешние относительно функции
										переменные.</li>
								</ol>
							</strong></p>
					</li>
					<li>
						<p>
							<strong>
								Область видимости определяет границы действия переменной. <br>
								Мы можем создавать локальные области видимости и использовать в них
								переменные с теми же названиями, что и у переменных из глобальной
								области видимости, при этом, это будут разные переменные (обращаться к
								переменным можно только если мы делаем это в их области видимости). <br>
								Всего есть три типа областей видимости:
								<ol>
									<li>Глобальная область видимости</li>
									<li>Локальная область видимости</li>
									<li>Область видимости блока</li>
								</ol>
								<p>НЕ РЕКОМЕНДУЕТСЯ присваивать значения переменным в локальной области,
									если переменные не были объявлены ранее, потому что тогда они будут
									автоматически созданы в глобальной области видимости.</p>
							</strong>
							<code>
								//Пример <br>
								let a <br>
								let b <br>
								function myFn() { <br>
								let b <br>
								} <br>
								<br>
								myFn() <br>
								console.log(a) //true <br>
								console.log(b) // undefined <br>
								//Здесь локальной областью видимости будет являться тело функции {} <br>
								let a / let b, объявленные в начале объявлены в глобальной области
								видимости.
							</code>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Если мы не знаем, присвоено ли переменной значение, мы можем сделать
								сравнение: <br>
								<code>
									let someVar // undefined <br>
									typeof someVar === 'undefined' //true <br>
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Логические операторы && и || являются операторами короткого замыкания,
								то есть возвращает результат одного из операндов (в зависимости от
								условия).
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Оператор разделения на свойства "..." важно указать в верном месте,
								потому что, если его указать перед свойством (при условии что свойство
								ранее уже было в оригинальном объекте), свойство будет перезаписано у
								оригинала. Если поставить после, оно не будет перезаписано.
							</strong>
							<code>
								//Пример: <br>
								const button = { <br>
								width:200, <br>
								text: 'Buy', <br>
								color: black <br>
								} <br>
								<br>
								const redButton = { <br>
								...button, <br>
								color: 'red' <br>
								} <br>
								// или <br>
								const redbutton = { <br>
								color: 'red', <br>
								...button <br>
								} <br>
							</code>
							<strong>
								Во втором случае 'red' будет перезаписано на black.
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Синтаксис шаблонной строки: <br>
								<code>
									const hello = 'Hello' <br>
									const world = 'World' <br>
									const smile = '=)' <br>
									<br>
									const greeting = `${hello} ${world} ${smile}` <br>
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Функциональное выражение отличается от функции тем, что у него нет
								имени.
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Стрелочные функции - это функции, которые не имеют ключевого слова
								function. <br>
								<code>
									(a, b) => { <br>
									let c <br>
									a = a + 1 <br>
									c = a + b <br>
									return c <br>
									} <br>
								</code>
								Стрелочная функция - это выражение, которое всегда анонимное. <br>
								Если мы хотим неявно вернуть объект, его нужно обернуть в (): <br>
								<code>
									const newPost = (post, addedAt = Date()) => ({ <br>
									...post, <br>
									addedAt, //то же, что и addedAt: addedAt, <br>
									}) <br>
									<br>
									const firstPost = { <br>
									id: 1, <br>
									author: 'Bogdan', <br>
									} <br>
									<br>
									newPost(firstPost) <br>
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Если свойства у объекта цифровые, мы не можем использовать точечную
								запись для получения доступа к ним. Используем только [] (актуально,
								например, для массивов).
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Методы массивов называются функциями высшего порядка в массивах.
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								<h3>Основные методы массивов.</h3>
								<p>Разберём на примере:</p>
								<code>
									const myArray = [1, 2, 3] <br>
									console.log(myArray) // [1, 2, 3] <br>
									myArray.push(4) <br>
									myArray.push(true) <br>
									console.log(myArray) // [1, 2, 3, 4, true] <br>
									<br>
									Переменная наследует все методы массивов.
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								Массив - это объект с цифровыми именами свойств. <br>
								Для доступа к элементам массива нельзя использовать точечную запись,
								используются квадратные скобки:
								<code>
									const myArray[1, 2, 3] <br>
									myArray[0] //1
								</code>
							</strong>
						</p>
					</li>
					<li>
						<h2>Методы массивов(//*500).</h2>
						<ul>
							<li>push <br>
								Добавляет новый элемент массива в конец. <br>
								<code>
									const myArray = [1, 2, 3]<br>
									myArray.push(4) <br>
									console.log(myArray) // [1, 2, 3, 4]<br>
								</code>
							</li>
							<li>pop<br>
								Этот метод позволяет убрать последний элемент из массива. <br>
								Если присвоить функции название (сделать переменную), можно будет
								вывести
								удалённый элемент массива. <br>
								<code>
									const myArray = [1, 2, 3, 4, 5] <br>
									const rem = myArray.pop() <br>
									const poppedElemOfmyArray = myArray <br>
									console.log(poppedElemOfmyArray) <br>
									console.log(myArray) <br>
									console.log(rem) <br>
								</code>
							</li>
							<li>unshift <br>
								Добавляет элемент в начале массива.
								<code>
									const myArray = [1, 2, 3] <br>
									console.log(myArray) // [1, 2, 3] <br>

									myArray.unshift(true) <br>

									console.log(myArray) // [true, 1, 2, 3] <br>

									myArray.unshift('abc') <br>

									console.log(myArray) //['abc', true, 1, 2, 3] <br>
								</code>
							</li>
							<li>shift <br>
								Удаляет первый элемент массива по аналогии с pop
								<br><br>
							</li>
							<li>forEach <br>
								<p>
									<strong>
										Метод массива forEach используется для операций с элементами массива
										без
										его мутирования:
										<code>
											const myArray = [1, 2, 3] <br>
											console.log(myArray) <br>
											<br>
											myArray.forEach(el => console.log(el * 2)) <br>
											<br>
											console.log(myArray) //[1, 2, 3] ориг. массив не изменился <br>
											<br>
										</code>
										В примере мы использовали callbackFn, которая вызывается
										соответственно
										с количеством элементов массива (3 раза).<br>
										У метода forEach отсутствует инструкция возврата, он не меняет
										оригинального м и ожидает callbackFn в
										качестве аргумента. <br>
										<br>
										Метод map действует по схожему принципу с forEach, перебирая каждый
										элемент массива, но формирует новый массив, поэтому крайне важно, что
										возвращает callbackFn переданная в его аргументе:
									</strong>
								</p>
								<p>ничего не возвращает</p>
							</li>
							<li>map <br>
								<code>
									const myArray = [1, 2, 3] <br>
									console.log(myArray) // [1, 2, 3] <br>
									<br>
									const newArray = myArray.map(el => el * 3) <br>
									<br>
									console.log(newArray) // [3, 6, 9] <br>
									console.log(myArray) // [1, 2, 3] //ориг. массив не изменился
								</code>
							</li>
							<li>reduce <br>
								<code>

								</code>
							</li>
							<li>и прочие...</li>
						</ul>
						<p>
							Первые 4 метода массивов мутируют объекты, несмотря на то, что массив из
							примера объявлен через const.
							Это возможно, потому что массив - это ссылочный тип объекта, а сама
							переменная сохраняет только ссылку на объект.
						</p>
						<p>
							Методы массивов называются функциями высшего порядка в массивах.
						</p>
					</li>

					<li>
						<p>
							<strong>
								Деструктуризация служит для того, чтобы создавать переменные и
								присваивать им значения, которые являются свойствами другого объекта, в
								одной строке. <br>
								<code>
									// Например, у нас есть объект: <br>
									const userProfile = { <br>
									name: 'Demian', <br>
									commentsQty: 23, <br>
									hasSignedAgreement: fasle <br>
									} <br>
									const { name, commentsQty } = userProfile //Здесь мы <br>
									const {hasSignedAgreement} = userProfile //объявляем новые переменные и
									присваиваем им значения на основании значений свойств объекта.<br>
								</code>
								Похожим образом мы можем объявить новые переменные и присвоить им
								значения на основе элементов массива. Важно помнить о том, что нужно
								учитывать порядок следования массивов. <br><br>
								Пример деструктуризации в функциях: <br>
								<code>
									const userProfile = { <br>
									name: 'Demian', <br>
									commentsQty: 23, <br>
									hasSignedAgreement: fasle <br>
									} <br>
									const userInfo = ({ name, commentsQty }) => { <br>
									if (!commentsQty) { <br>
									return `User ${name} has no comments` <br>
									} <br>
									return `User ${name} has ${commentsQty} comments` <br>
									} <br>
									userInfo(userProfile) // User Demian has 23 comments <br>
								</code>
							</strong>
						</p>
					</li>
					<li>
						<p>
							<strong>
								циклы массивов: <br>

							</strong>
						</p>
					</li>
					<li>
						<strong>
							<p>
								Конструктор - это метод, который вызывается, когда вызываются новые
								экземпляры класса. В итоге такой метод вернет новый объект.<br>
								Чтобы создать новый экземпляр класса, используется унарный оператор new.
							</p>
						</strong>
					</li>
				</ul>
			</section>

		</div>
		<script>
		window.addEventListener('scroll', function () {
			const scroll = document.querySelector('.up_ward');
			scroll.classList.toggle("active", window.scrollY > 400)
		})
		const scrollTopTop = () => {
			window.scrollTo({
				top: 0,
				behavior: 'smooth'
			})
		} 
		</script>
		<script src="../Стащук/js/index.js"></script>
	</body>
</html>